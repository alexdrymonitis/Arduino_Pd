#N canvas 711 464 732 457 10;
#X obj 30 102 inlet;
#X obj 30 353 outlet;
#X text 29 386 Written by Alexandros Drymonitis;
#N canvas 520 265 636 354 repack 0;
#X obj 36 27 inlet;
#X obj 36 49 route float bang;
#X obj 36 157 + 1;
#X obj 84 206 t l l;
#X obj 84 184 list prepend;
#X obj 36 181 sel;
#X obj 271 216 inlet data_amount;
#X obj 63 251 outlet;
#X obj 36 71 t b f;
#X obj 63 229 list;
#X obj 206 215 sel 0 1, f 8;
#X obj 271 239 route 0 1;
#X obj 206 257 f;
#X obj 228 281 f;
#X text 336 237 these are the two groups of values;
#X obj 36 203 t b b;
#X obj 36 134 f;
#X obj 235 170 0;
#X obj 206 170 1;
#X obj 82 116 0;
#X obj 82 93 t b b;
#X obj 82 71 t b b, f 26;
#X obj 179 103 t b b;
#X connect 0 0 1 0;
#X connect 1 0 8 0;
#X connect 1 1 21 0;
#X connect 2 0 16 1;
#X connect 2 0 5 0;
#X connect 3 0 9 1;
#X connect 3 1 4 1;
#X connect 4 0 3 0;
#X connect 5 0 15 0;
#X connect 6 0 11 0;
#X connect 8 0 16 0;
#X connect 8 1 4 0;
#X connect 9 0 7 0;
#X connect 10 0 12 0;
#X connect 10 1 13 0;
#X connect 11 0 12 1;
#X connect 11 1 13 1;
#X connect 12 0 5 1;
#X connect 13 0 5 1;
#X connect 15 0 22 0;
#X connect 15 1 9 0;
#X connect 16 0 2 0;
#X connect 17 0 10 0;
#X connect 18 0 10 0;
#X connect 19 0 16 1;
#X connect 20 0 19 0;
#X connect 20 1 4 1;
#X connect 21 0 20 0;
#X connect 21 1 17 0;
#X connect 22 0 20 0;
#X connect 22 1 18 0;
#X restore 30 232 pd repack;
#X obj 227 296 outlet;
#X obj 402 190 inlet change_num_of_data;
#X obj 234 190 t f f;
#N canvas 665 319 874 377 \$0-route_list 0;
#X obj 31 249 f;
#X obj 61 249 == 0;
#X obj 31 48 t b l;
#X obj 31 26 inlet;
#X obj 31 272 list append;
#X obj 31 318 outlet;
#X obj 130 318 outlet;
#X obj 130 274 inlet which_is_analog;
#N canvas 164 589 450 300 specify_analog 0;
#X obj 55 130 t l l;
#X obj 55 173 spigot;
#X obj 105 173 spigot;
#X obj 205 130 t l l;
#X obj 205 173 spigot;
#X obj 255 173 spigot;
#N canvas 505 251 499 346 assemble_analog 0;
#X obj 38 81 list split 2;
#X obj 53 106 list;
#X obj 144 152 unpack;
#X obj 144 192 +;
#X obj 183 174 * 128;
#X obj 38 56 inlet bytes;
#X obj 119 282 outlet;
#X obj 144 215 list prepend;
#X obj 144 237 t l l;
#X obj 38 134 t b l;
#X obj 119 259 list;
#X obj 119 104 t b b;
#X text 36 10 this used to be the [read_analog_pins] abstraction \, which is now integrated in the [serial_write] abstraction.;
#X connect 0 0 9 0;
#X connect 0 1 1 1;
#X connect 0 2 11 0;
#X connect 1 0 0 0;
#X connect 2 0 3 0;
#X connect 2 1 4 0;
#X connect 3 0 7 0;
#X connect 4 0 3 1;
#X connect 5 0 0 0;
#X connect 7 0 8 0;
#X connect 8 0 10 1;
#X connect 8 1 7 1;
#X connect 9 0 1 0;
#X connect 9 1 2 0;
#X connect 10 0 6 0;
#X connect 11 0 10 0;
#X connect 11 1 7 1;
#X restore 105 203 pd assemble_analog;
#N canvas 509 255 525 347 assemble_analog 0;
#X obj 38 81 list split 2;
#X obj 51 106 list;
#X obj 144 152 unpack;
#X obj 144 192 +;
#X obj 183 174 * 128;
#X obj 38 56 inlet bytes;
#X obj 119 282 outlet;
#X obj 144 215 list prepend;
#X obj 144 237 t l l;
#X obj 38 134 t b l;
#X obj 119 259 list;
#X obj 119 104 t b b;
#X text 36 10 this used to be the [read_analog_pins] abstraction \, which is now integrated in the [serial_write] abstraction.;
#X connect 0 0 9 0;
#X connect 0 1 1 1;
#X connect 0 2 11 0;
#X connect 1 0 0 0;
#X connect 2 0 3 0;
#X connect 2 1 4 0;
#X connect 3 0 7 0;
#X connect 4 0 3 1;
#X connect 5 0 0 0;
#X connect 7 0 8 0;
#X connect 8 0 10 1;
#X connect 8 1 7 1;
#X connect 9 0 1 0;
#X connect 9 1 2 0;
#X connect 10 0 6 0;
#X connect 11 0 10 0;
#X connect 11 1 7 1;
#X restore 255 203 pd assemble_analog;
#X obj 55 238 outlet;
#X obj 205 238 outlet;
#X obj 237 35 inlet which_is_analog;
#X obj 138 149 == 0;
#X obj 238 149 == 0;
#X obj 237 57 t f f f f;
#X obj 55 67 inlet;
#X obj 55 89 route 0 1;
#X connect 0 0 1 0;
#X connect 0 1 2 0;
#X connect 1 0 8 0;
#X connect 2 0 6 0;
#X connect 3 0 4 0;
#X connect 3 1 5 0;
#X connect 4 0 9 0;
#X connect 5 0 7 0;
#X connect 6 0 8 0;
#X connect 7 0 9 0;
#X connect 10 0 13 0;
#X connect 11 0 2 1;
#X connect 12 0 4 1;
#X connect 13 0 1 1;
#X connect 13 1 11 0;
#X connect 13 2 12 0;
#X connect 13 3 5 1;
#X connect 14 0 15 0;
#X connect 15 0 0 0;
#X connect 15 1 3 0;
#X restore 31 296 pd specify_analog;
#X text 81 19 if we don't provide a second argument \, use 1 to compare [f] so that it always outputs 0 \, else use 0;
#X obj 82 50 r \$0-num_args;
#X obj 297 120 r \$0-arg_type;
#X obj 240 142 sel analog;
#X obj 240 97 r \$0-message_type;
#X obj 297 164 t b;
#X msg 297 231 0;
#X obj 297 209 spigot;
#X obj 82 74 t f f;
#X text 343 212 if we have already provided four arguments \, then don't let the messages control whether we receive both analog and digital values;
#X text 399 120 if we have provided two arguments only \, set the type of argument to see if a message we send is of the same type \, so that we don't change the alternating counter. if it's of the other type \, we need the counter to alternate between 0 and 1;
#X connect 0 0 1 0;
#X connect 0 0 4 0;
#X connect 1 0 0 1;
#X connect 2 0 0 0;
#X connect 2 1 4 1;
#X connect 3 0 2 0;
#X connect 4 0 8 0;
#X connect 7 0 8 1;
#X connect 8 0 5 0;
#X connect 8 1 6 0;
#X connect 10 0 17 0;
#X connect 11 0 12 1;
#X connect 12 1 14 0;
#X connect 13 0 12 0;
#X connect 14 0 16 0;
#X connect 15 0 1 1;
#X connect 16 0 15 0;
#X connect 17 0 1 1;
#X connect 17 1 16 1;
#X restore 30 256 pd \$0-route_list;
#N canvas 401 264 799 340 \$0-change_num_of_data 0;
#X obj 12 44 inlet which_is_analog;
#X obj 175 67 route analog digital;
#X obj 175 160 f;
#X obj 221 142 t f f;
#X obj 233 164 f;
#X obj 175 182 pack;
#X obj 175 252 outlet;
#X obj 233 186 == 0;
#X obj 233 208 pack, f 5;
#X obj 175 20 inlet change_num_of_data;
#X obj 202 112 * 2;
#X obj 175 42 t a a;
#X obj 358 60 unpack s f;
#X obj 358 82 s \$0-message_type;
#X obj 175 89 t b f;
#X obj 233 90 t b f;
#X connect 0 0 3 0;
#X connect 1 0 14 0;
#X connect 1 1 15 0;
#X connect 2 0 5 0;
#X connect 3 0 2 1;
#X connect 3 1 4 1;
#X connect 4 0 7 0;
#X connect 5 0 6 0;
#X connect 7 0 8 0;
#X connect 8 0 6 0;
#X connect 9 0 11 0;
#X connect 10 0 5 1;
#X connect 11 0 1 0;
#X connect 11 1 12 0;
#X connect 12 0 13 0;
#X connect 14 0 2 0;
#X connect 14 1 10 0;
#X connect 15 0 4 0;
#X connect 15 1 8 1;
#X restore 261 214 pd \$0-change_num_of_data;
#N canvas 186 125 982 483 \$0-assemble_num_of_data 0;
#X obj 58 348 outlet;
#X obj 58 36 loadbang;
#X obj 58 92 t b b;
#X obj 107 131 sel analog digital;
#X msg 107 209 2;
#X msg 159 231 1;
#X obj 58 249 *;
#X obj 58 58 t b b;
#X obj 358 76 t b b;
#X obj 358 106 \$2;
#X obj 407 156 sel analog digital;
#X obj 407 94 symbol \$1;
#X msg 407 202 2;
#X msg 459 202 1;
#X obj 358 242 *;
#X obj 107 110 symbol \$3;
#X obj 58 114 \$4;
#X msg 358 269 0 \$1;
#X msg 58 271 1 \$1;
#X text 395 269 first group of values;
#X text 94 270 second group of values;
#X text 55 2 analog values are split in two \, so we receive two bytes per value. digital values are being received as is.;
#X obj 407 179 t b b;
#X msg 510 197 0;
#X obj 107 186 t b b;
#X msg 195 204 1;
#X obj 510 350 outlet which_is_analog;
#X obj 244 171 s \$0-num_args;
#X msg 543 174 at least two arguments needed;
#X obj 407 116 t s s;
#X obj 471 134 s \$0-arg_type;
#X obj 543 196 print serial_write;
#X obj 459 224 t f f;
#X text 519 218 if first group is digital \, set which is analog \, because we might not receive further arguments \, in case we use only digital;
#X msg 244 149 1;
#X connect 1 0 7 0;
#X connect 2 0 16 0;
#X connect 2 1 15 0;
#X connect 3 0 24 0;
#X connect 3 1 5 0;
#X connect 3 2 34 0;
#X connect 4 0 6 1;
#X connect 5 0 6 1;
#X connect 6 0 18 0;
#X connect 7 0 2 0;
#X connect 7 1 8 0;
#X connect 8 0 9 0;
#X connect 8 1 11 0;
#X connect 9 0 14 0;
#X connect 10 0 22 0;
#X connect 10 1 13 0;
#X connect 10 2 28 0;
#X connect 11 0 29 0;
#X connect 12 0 14 1;
#X connect 13 0 32 0;
#X connect 14 0 17 0;
#X connect 15 0 3 0;
#X connect 16 0 6 0;
#X connect 17 0 0 0;
#X connect 18 0 0 0;
#X connect 22 0 12 0;
#X connect 22 1 23 0;
#X connect 23 0 26 0;
#X connect 24 0 4 0;
#X connect 24 1 25 0;
#X connect 25 0 26 0;
#X connect 28 0 31 0;
#X connect 29 0 10 0;
#X connect 29 1 30 0;
#X connect 32 0 14 1;
#X connect 32 1 26 0;
#X connect 34 0 27 0;
#X restore 81 166 pd \$0-assemble_num_of_data;
#N canvas 579 351 354 270 set_initializer 0;
#X obj 57 70 loadbang;
#X obj 57 92 \$5;
#X obj 57 114 sel 0;
#X msg 57 136 192;
#X obj 57 158 outlet;
#X obj 126 70 inlet;
#X connect 0 0 1 0;
#X connect 1 0 2 0;
#X connect 2 0 3 0;
#X connect 2 1 4 0;
#X connect 3 0 4 0;
#X connect 5 0 2 0;
#X restore 514 62 pd set_initializer;
#X obj 514 40 inlet;
#X obj 83 287 r \$0-num_args;
#X obj 30 305 spigot;
#X obj 30 330 list;
#X obj 30 278 t b l;
#X text 80 316 if we receive two arguments only \, force a bang when the first package finishes;
#X obj 30 147 select;
#X obj 195 274 t b l;
#X obj 30 124 spigot;
#X obj 514 84 t b f;
#X msg 514 107 1;
#X text 27 9 This abstraction uses the technique found in the rePatcher by Open Music Labs (slightly modified) \, to receive data from the Arduino. It needs a unique byte to denote the beginning of the data stream (which is 192 by default \, [sel]s' argument) after which \, all bytes are being collected by [pd repack] and dumped as a list.;
#X connect 0 0 19 0;
#X connect 3 0 7 0;
#X connect 5 0 8 1;
#X connect 6 0 7 1;
#X connect 6 1 8 0;
#X connect 7 0 15 0;
#X connect 7 1 18 0;
#X connect 8 0 3 1;
#X connect 9 0 3 1;
#X connect 9 1 6 0;
#X connect 10 0 20 0;
#X connect 11 0 10 0;
#X connect 12 0 13 1;
#X connect 13 0 14 0;
#X connect 14 0 1 0;
#X connect 15 0 13 0;
#X connect 15 1 14 1;
#X connect 17 0 3 0;
#X connect 17 1 3 0;
#X connect 18 0 14 0;
#X connect 18 1 4 0;
#X connect 19 0 17 0;
#X connect 20 0 21 0;
#X connect 20 1 17 1;
#X connect 21 0 19 1;
